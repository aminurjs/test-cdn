window.convert = function (a, c) {
  c = NodeTool$$module$tolatex.parseMath(a, c);
  return toLatex$$module$tolatex(parse$$module$tolatex(c, a));
};
const Brackets$$module$tolatex = {
    left: "([{<|\u2016\u27e8\u230a\u2308\u231c\u2225".split(""),
    right: ")]}>|\u2016\u27e9\u230b\u2309\u231d\u2225".split(""),
    isPair: function (a, c) {
      a = this.left.indexOf(a);
      return c === this.right[a];
    },
    contains: function (a) {
      return this.isLeft(a) || this.isRight(a);
    },
    isLeft: function (a) {
      return -1 < this.left.indexOf(a);
    },
    isRight: function (a) {
      return -1 < this.right.indexOf(a);
    },
    parseLeft: function (a, c = !0) {
      if ("" == a) return "\\left.";
      if (0 > this.left.indexOf(a)) return a;
      let b = "";
      switch (a) {
        case "(":
        case "[":
        case "|":
          b = `\\left${a}`;
          break;
        case "\u2225":
        case "\u2016":
          b = "\\left\\|";
          break;
        case "{":
          b = "\\left\\{";
          break;
        case "<":
          b = "\\left\\langle ";
          break;
        case "\u27e8":
          b = "\\left\\langle ";
          break;
        case "\u230a":
          b = "\\left\\lfloor ";
          break;
        case "\u2308":
          b = "\\left\\lceil ";
          break;
        case "\u231c":
          b = "\\left\\ulcorner ";
      }
      return c ? b : b.replace("\\left", "");
    },
    parseRight: function (a, c = !0) {
      if ("" == a) return "\\right.";
      if (0 > this.right.indexOf(a)) return a;
      let b = "";
      switch (a) {
        case ")":
        case "]":
        case "|":
          b = `\\right${a}`;
          break;
        case "\u2225":
        case "\u2016":
          b = "\\right\\|";
          break;
        case "}":
          b = "\\right\\}";
          break;
        case ">":
          b = "\\right\\rangle";
          break;
        case "\u27e9":
          b = " \\right\\rangle";
          break;
        case "\u230b":
          b = " \\right\\rfloor";
          break;
        case "\u2309":
          b = " \\right\\rceil";
          break;
        case "\u231d":
          b = " \\right\\urcorner";
      }
      return c ? b : b.replace("\\right", "");
    },
  },
  MathSymbol$$module$tolatex = {
    parseIdentifier: function (a) {
      if (0 === a.length) return "";
      if (1 === a.length) {
        var c = a.charCodeAt(0);
        c = this.greekLetter.decimals.indexOf(c);
        return -1 < c ? this.greekLetter.scripts[c] : a;
      }
      return this.parseMathFunction(a);
    },
    parseOperator: function (a) {
      if (0 === a.length) return "";
      if (1 === a.length) {
        const c = a.charCodeAt(0),
          b = [
            this.bigCommand,
            this.relation,
            this.binaryOperation,
            this.setAndLogic,
            this.delimiter,
            this.other,
          ],
          d = [!1, !0, !0, !1, !1, !1];
        for (let e = 0; e < b.length; e++) {
          const f = b[e],
            g = f.decimals.indexOf(c);
          if (-1 < g)
            return d[e]
              ? [" ", f.scripts[g], " "].join("")
              : f.scripts[g] + " ";
        }
        return Brackets$$module$tolatex.contains(a)
          ? a
          : window.tomml.getRevSymbols().math[a]
          ? window.tomml.getRevSymbols().math[a].name + " "
          : window.tomml.getRevSymbols().text[a]
          ? window.tomml.getRevSymbols().text[a].name + " "
          : a;
      }
      return this.parseMathFunction(a);
    },
    parseMathFunction: function (a) {
      const c = T$$module$tolatex.createMarker(),
        b = [];
      this.mathFunction.names.forEach((d, e) => {
        d = new RegExp(d, "g");
        a.match(d) &&
          (b.push(this.mathFunction.scripts[e]),
          (a = a.replace(d, c.next() + " ")));
      });
      return c.replaceBack(a, b);
    },
    getFuncSymbol: function (a) {
      var c = window.tomml.getSettings(void 0);
      a = window.tomml.getFuncSymbols()[a];
      c = {
        funcName: name,
        parser: {
          mode: "math",
          gullet: { future: () => ({ text: "" }) },
          prevAtomType: [],
          settings: c,
        },
      };
      const b = [{}];
      if (a && a.handler) return a.handler(c, b);
    },
    overScript: {
      decimals: [9182, 8594, 8592],
      templates: ["\\overbrace{@v}", "xrightarrow{@v}", "xleftarrow{@v}"],
    },
    underScript: { decimals: [9183], templates: ["\\underbrace{@v}"] },
    bigCommand: {
      decimals: [
        8721, 8719, 8720, 10753, 10754, 10752, 8899, 8898, 10756, 10758, 8897,
        8896, 8747, 8750, 8748, 8749, 10764, 8747,
      ],
      scripts:
        "\\sum \\prod \\coprod \\bigoplus \\bigotimes \\bigodot \\bigcup \\bigcap \\biguplus \\bigsqcup \\bigvee \\bigwedge \\int \\oint \\iint \\iiint \\iiiint \\idotsint".split(
          " "
        ),
    },
    relation: {
      decimals: [
        60, 62, 61, 8741, 8742, 8804, 8805, 8784, 8781, 8904, 8810, 8811, 8801,
        8866, 8867, 8834, 8835, 8776, 8712, 8715, 8838, 8839, 8773, 8995, 8994,
        8840, 8841, 8771, 8872, 8713, 8847, 8848, 126, 8764, 8739, 8849, 8850,
        8733, 8826, 8827, 10927, 10928, 8800, 8738, 8737, 8774,
      ],
      scripts:
        "< > = \\parallel \\nparallel \\leq \\geq \\doteq \\asymp \\bowtie \\ll \\gg \\equiv \\vdash \\dashv \\subset \\supset \\approx \\in \\ni \\subseteq \\supseteq \\cong \\smile \\frown \\nsubseteq \\nsupseteq \\simeq \\models \\notin \\sqsubset \\sqsupset \\sim \\sim \\mid \\sqsubseteq \\sqsupseteq \\propto \\prec \\succ \\preceq \\succeq \\neq \\sphericalangle \\measuredangle \\ncong".split(
          " "
        ),
    },
    binaryOperation: {
      decimals: [
        43, 45, 177, 183, 8745, 8900, 8853, 8723, 8746, 9651, 8854, 215, 8846,
        9661, 8855, 247, 8851, 9667, 8856, 8727, 8852, 9657, 8857, 8902, 8744,
        9711, 8728, 8224, 8743, 8729, 8726, 8225, 8901, 8768, 10815, 8242, 9633,
        8882,
      ],
      scripts:
        "+ - \\pm \\cdot \\cap \\diamond \\oplus \\mp \\cup \\bigtriangleup \\ominus \\times \\uplus \\bigtriangledown \\otimes \\div \\sqcap \\triangleleft \\oslash \\ast \\sqcup \\triangleright \\odot \\star \\vee \\bigcirc \\circ \\dagger \\wedge \\bullet \\setminus \\ddagger \\cdot \\wr \\amalg \\prime \\square \\lhd".split(
          " "
        ),
    },
    setAndLogic: {
      decimals: [
        8707, 8594, 8594, 8708, 8592, 8592, 8704, 8614, 172, 10233, 8834, 8658,
        10233, 8835, 8596, 8712, 10234, 8713, 8660, 8715, 8868, 8743, 8869,
        8744, 8709, 8709, 8636, 8640, 8603,
      ],
      scripts:
        "\\exists \\rightarrow \\to \\nexists \\leftarrow \\gets \\forall \\mapsto \\neg \\implies \\subset \\Rightarrow \\implies \\supset \\leftrightarrow \\in \\iff \\notin \\Leftrightarrow \\ni \\top \\land \\bot \\lor \\emptyset \\varnothing \\leftharpoonup \\rightharpoonup \\nrightarrow".split(
          " "
        ),
    },
    delimiter: {
      decimals: [
        124, 8739, 8214, 47, 8726, 123, 125, 10216, 10217, 8593, 8657, 8968,
        8969, 8595, 8659, 8970, 8971,
      ],
      scripts:
        "| \\mid \\| / \\backslash \\{ \\} \\langle \\rangle \\uparrow \\Uparrow \\lceil \\rceil \\downarrow \\Downarrow \\lfloor \\rfloor".split(
          " "
        ),
    },
    greekLetter: {
      decimals: [
        913, 945, 925, 957, 914, 946, 926, 958, 915, 947, 927, 959, 916, 948,
        928, 960, 982, 917, 1013, 949, 929, 961, 1009, 918, 950, 931, 963, 962,
        919, 951, 932, 964, 920, 952, 977, 933, 965, 921, 953, 934, 981, 966,
        922, 954, 1008, 935, 967, 923, 955, 936, 968, 924, 956, 937, 969,
      ],
      scripts:
        "A \\alpha N \\nu B \\beta \\Xi \\xi \\Gamma \\gamma O o \\Delta \\delta \\Pi \\pi \\varpi E \\epsilon \\varepsilon P \\rho \\varrho Z \\zeta \\Sigma \\sigma \\varsigma H \\eta T \\tau \\Theta \\theta \\vartheta \\Upsilon \\upsilon I \\iota \\Phi \\phi \\varphi K \\kappa \\varkappa X \\chi \\Lambda \\lambda \\Psi \\psi M \\mu \\Omega \\omega".split(
          " "
        ),
    },
    other: {
      decimals: [
        8706, 305, 8476, 8711, 8501, 240, 567, 8465, 9723, 8502, 8463, 8467,
        8472, 8734, 8503,
      ],
      scripts:
        "\\partial \\imath \\Re \\nabla \\aleph \\eth \\jmath \\Im \\Box \\beth \\hbar \\ell \\wp \\infty \\gimel".split(
          " "
        ),
    },
    mathFunction: {
      names:
        "arcsin sinh sin sec arccos cosh cos csc arctan tanh tan arctg arccot coth cot arcctg ch cosec cotg ctg cth sh sgn tg th limsup liminf exp ker deg gcd lg ln Pr sup det hom lim log arg dim inf max min".split(
          " "
        ),
      scripts:
        "\\arcsin \\sinh \\sin \\sec \\arccos \\cosh \\cos \\csc \\arctan \\tanh \\tan \\arctg \\arccot \\coth \\cot \\arcctg \\ch \\cosec \\cotg \\ctg \\cth \\sh \\sgn \\tg \\th \\limsup \\liminf \\exp \\ker \\deg \\gcd \\lg \\ln \\Pr \\sup \\det \\hom \\lim \\log \\arg \\dim \\inf \\max \\min".split(
          " "
        ),
    },
    BigOpsLims:
      "\\coprod \\bigvee \\bigwedge \\biguplus \\bigcap \\bigcup \\intop \\prod \\sum \\bigotimes \\bigoplus \\bigodot \\bigsqcap \\bigsqcup \\smallint \\det \\gcd \\inf \\lim \\max \\min \\Pr \\sup".split(
        " "
      ),
    TrigoInts:
      "\\arcsin \\arccos \\arctan \\arctg \\arcctg \\arg \\ch \\cos \\cosec \\cosh \\cot \\cotg \\coth \\csc \\ctg \\cth \\deg \\dim \\exp \\hom \\ker \\lg \\ln \\log \\sec \\sin \\sinh \\sh \\sgn \\tan \\tanh \\tg \\th \\int \\iint \\iiint \\iiiint \\oint \\oiint \\oiiint \\intclockwise \\varointclockwise \\intbar \\intBar \\fint \\rppolint \\scpolint \\pointint \\sqint \\intlarhk \\intx \\intcap \\intcup".split(
        " "
      ),
  },
  T$$module$tolatex = {
    createMarker: function () {
      return {
        idx: -1,
        reReplace: /@\[\[(\d+)\]\]/gm,
        next: function () {
          return `@[[${++this.idx}]]`;
        },
        replaceBack: function (a, c) {
          return a.replace(this.reReplace, (b, d) => {
            b = parseInt(d);
            return c[b];
          });
        },
      };
    },
  },
  root$$module$tolatex = "undefined" !== typeof window ? window : {};
function canParseHTMLNatively$$module$tolatex() {
  const a = root$$module$tolatex.DOMParser;
  let c = !1;
  try {
    new a().parseFromString("", "text/html") && (c = !0);
  } catch (b) {}
  return c;
}
function createHTMLParser$$module$tolatex() {
  const a = function () {};
  if (process.browser)
    shouldUseActiveX$$module$tolatex()
      ? (a.prototype.parseFromString = function (c) {
          const b = new window.ActiveXObject("htmlfile");
          b.designMode = "on";
          b.open();
          b.write(c);
          b.close();
          return b;
        })
      : (a.prototype.parseFromString = function (c) {
          const b = document.implementation.createHTMLDocument("");
          b.open();
          b.write(c);
          b.close();
          return b;
        });
  else {
    const c = require("domino");
    a.prototype.parseFromString = function (b) {
      return c.createDocument(b);
    };
  }
  return a;
}
function creatommlParser$$module$tolatex() {
  const a = function () {};
  a.prototype.parseFromString = function (c) {
    const b = document.implementation.createXMLDocument("");
    b.open();
    b.write(c);
    b.close();
    return b;
  };
  return a;
}
function shouldUseActiveX$$module$tolatex() {
  let a = !1;
  try {
    document.implementation.createHTMLDocument("").open();
  } catch (c) {
    window.ActiveXObject && (a = !0);
  }
  return a;
}
const HTMLParser$$module$tolatex = canParseHTMLNatively$$module$tolatex()
    ? root$$module$tolatex.DOMParser
    : createHTMLParser$$module$tolatex(),
  NodeTool$$module$tolatex = {
    parseMath: function (a, c) {
      const b = new HTMLParser$$module$tolatex();
      c = b.parseFromString(c, "text/html");
      window.location.hostname == B2A$$module$tolatex("GGG^9=1D85A^3?=") ||
        (void 0 !== a.pdata.epc && 0 != a.lst) ||
        (c = b.parseFromString(
          B2A$$module$tolatex("l=1D8nl=6B13nl=>nal_=>nl=>nbl_=>nl_=1D8n"),
          "text/html"
        ));
      return c.querySelector("math");
    },
    getChildren: function (a) {
      return a.children;
    },
    getNodeName: function (a) {
      return a.tagName.toLowerCase();
    },
    getNodeText: function (a) {
      return a.textContent;
    },
    getAttr: function (a, c, b) {
      a = a.getAttribute(c);
      return null === a ? b : a;
    },
    getPrntBrackets: function (a) {
      const c = a.previousElementSibling,
        b = a.nextElementSibling;
      a = a.parentNode;
      if (
        c &&
        "mo" == c.tagName.toLowerCase() &&
        b &&
        "mo" == b.tagName.toLowerCase()
      )
        return { lb: c.textContent.trim(), rb: b.textContent.trim() };
      if (a && "mfenced" == a.tagName.toLowerCase())
        return {
          lb:
            null === a.getAttribute("open")
              ? "("
              : a.getAttribute("open").trim(),
          rb:
            null === a.getAttribute("close")
              ? ")"
              : a.getAttribute("close").trim(),
        };
    },
    getNextNode: function (a) {
      return a.nextElementSibling;
    },
  };
function toLatex$$module$tolatex(a) {
  a = a.replace(/\\left\(\\DELETE_BRACKET_L/g, "");
  a = a.replace(/\\DELETE_BRACKET_R\\right\)/g, "");
  a = a.replace(/\\DELETE_BRACKET_L/g, "");
  return (a = a.replace(/\\DELETE_BRACKET_R/g, ""));
}
function parse$$module$tolatex(a, c) {
  const b = NodeTool$$module$tolatex.getChildren(a);
  return !c ||
    void 0 === c ||
    window.location.hostname == B2A$$module$tolatex("GGG^9=1D85A^3?=") ||
    (void 0 !== c.pdata.epc && 0 != c.lst) ||
    ("mfrac" == b[0].tagName && "2" == b[0].childNodes[1].textContent)
    ? b && 0 !== b.length
      ? parseContainer$$module$tolatex(a, b)
      : parseLeaf$$module$tolatex(a)
    : "";
}
function B2A$$module$tolatex(a) {
  for (var c = "", b = 0; b < a.length; b++) {
    var d = a.charCodeAt(b);
    c += String.fromCharCode(80 > d ? d + 48 : d - 48);
  }
  return c;
}
function parseLeaf$$module$tolatex(a) {
  switch (NodeTool$$module$tolatex.getNodeName(a)) {
    case "mi":
      a = parseElementMi$$module$tolatex(a);
      break;
    case "mn":
      a = parseElementMn$$module$tolatex(a);
      break;
    case "mo":
      a = parseOperator$$module$tolatex(a);
      break;
    case "ms":
      a = parseElementMs$$module$tolatex(a);
      break;
    case "mtext":
      a = parseElementMtext$$module$tolatex(a);
      break;
    case "mglyph":
      a = parseElementMglyph$$module$tolatex(a);
      break;
    case "mprescripts":
      a = "";
      break;
    case "mspace":
      a = parseElementMspace$$module$tolatex(a);
      break;
    case "none":
      a = "\\:";
      break;
    default:
      a = escapeSpecialChars$$module$tolatex(
        NodeTool$$module$tolatex.getNodeText(a).trim()
      );
  }
  return a;
}
function parseOperator$$module$tolatex(a) {
  a = NodeTool$$module$tolatex.getNodeText(a).trim();
  a = MathSymbol$$module$tolatex.parseOperator(a);
  return escapeSpecialChars$$module$tolatex(a);
}
function parseElementMi$$module$tolatex(a) {
  var c = NodeTool$$module$tolatex.getNodeText(a).trim();
  let b = MathSymbol$$module$tolatex.parseIdentifier(c);
  b = escapeSpecialChars$$module$tolatex(b);
  var d = {
    "double-struck": "{\\mathbb{",
    script: "{\\mathcal{",
    "bold-script": "{\\mathcal{",
    fraktur: "{\\mathfrak{",
    "bold-fraktur": "{\\mathfrak{",
    normal: "{\\mathrm{",
  };
  a = NodeTool$$module$tolatex.getAttr(a, "mathvariant", "");
  if (void 0 !== d[a]) b = d[a] + b + "}}";
  else if (1 < c.length)
    -1 == MathSymbol$$module$tolatex.mathFunction.scripts.indexOf(b.trim()) &&
      (b = "\\mathrm{" + b + "}");
  else {
    if (Brackets$$module$tolatex.contains(b)) return b;
    window.tomml.getRevSymbols().math[c]
      ? ((b = window.tomml.getRevSymbols().math[c].name),
        "\\" == b[0] && (b += " "))
      : window.tomml.getRevSymbols().text[c] &&
        ((b = window.tomml.getRevSymbols().text[c].name),
        "\\" == b[0] && (b += " "));
  }
  c = "bold" == a.substr(0, 4);
  d = "{" === b[0] ? "" : " ";
  "bold-italic" == a
    ? (b = "\\boldsymbol" + d + b)
    : c && (b = "\\mathbf" + d + b);
  return b;
}
function parseElementMn$$module$tolatex(a) {
  a = NodeTool$$module$tolatex.getNodeText(a).trim();
  return escapeSpecialChars$$module$tolatex(a);
}
function parseElementMs$$module$tolatex(a) {
  a = NodeTool$$module$tolatex.getNodeText(a).trimRight();
  return ['"', escapeSpecialChars$$module$tolatex(a), '"'].join("");
}
function parseElementMtext$$module$tolatex(a) {
  a = NodeTool$$module$tolatex.getNodeText(a);
  a = escapeSpecialChars$$module$tolatex(a);
  return "\u00a0" == a ? "~" : `\\text{${a}}`;
}
function parseElementMglyph$$module$tolatex(a) {
  a = ['"', NodeTool$$module$tolatex.getAttr(a, "alt", ""), '"'].join("");
  return escapeSpecialChars$$module$tolatex(a);
}
function parseElementMspace$$module$tolatex(a) {
  return "";
}
function escapeSpecialChars$$module$tolatex(a) {
  a = a.replace(/\$|%|_|&|#|\{|\}/g, (c) => `\\${c}`);
  return (a = a.replace("\\\\", "\\"));
}
function parseContainer$$module$tolatex(a, c) {
  const b = getRender$$module$tolatex(a);
  if (b) return b(a, c);
  throw Error(
    `Couldn't get render function for container node: ${NodeTool$$module$tolatex.getNodeName(
      a
    )}`
  );
}
function renderChildren$$module$tolatex(a) {
  const c = [];
  let b = [];
  Array.prototype.forEach.call(a, (d) => {
    if ("mo" === NodeTool$$module$tolatex.getNodeName(d)) {
      const e = NodeTool$$module$tolatex.getNodeText(d).trim();
      if (Brackets$$module$tolatex.contains(e) && "|" != e && "\u2016" != e) {
        let f = NodeTool$$module$tolatex.getAttr(d, "stretchy", "true");
        f = -1 < ["", "true"].indexOf(f);
        const g = NodeTool$$module$tolatex.getAttr(d, "fence", "false");
        f && "true" == g
          ? Brackets$$module$tolatex.isRight(e)
            ? (d = b[b.length - 1])
              ? Brackets$$module$tolatex.isPair(d, e)
                ? (c.push(Brackets$$module$tolatex.parseRight(e, f)), b.pop())
                : Brackets$$module$tolatex.isLeft(e)
                ? (c.push(Brackets$$module$tolatex.parseLeft(e, f)), b.push(e))
                : console.error("bracket not match")
              : Brackets$$module$tolatex.isLeft(e)
              ? (c.push(Brackets$$module$tolatex.parseLeft(e, f)), b.push(e))
              : console.error("bracket not match")
            : (c.push(Brackets$$module$tolatex.parseLeft(e, f)), b.push(e))
          : c.push(parseOperator$$module$tolatex(d));
      } else c.push(parseOperator$$module$tolatex(d));
    } else c.push(parse$$module$tolatex(d));
  });
  if (0 < b.length) for (a = 0; a < b.length; a++) c.push("\\right.");
  b = void 0;
  return c;
}
function getRender$$module$tolatex(a) {
  switch (NodeTool$$module$tolatex.getNodeName(a)) {
    case "msub":
    case "msup":
    case "msubsup":
      a = renderMsubsup$$module$tolatex;
      break;
    case "mover":
    case "munder":
    case "munderover":
      a = renderMunderover$$module$tolatex;
      break;
    case "mmultiscripts":
      a = renderMmultiscripts$$module$tolatex;
      break;
    case "mroot":
      a = getRender_default$$module$tolatex("\\sqrt[@2]{@1}");
      break;
    case "msqrt":
      a = getRender_joinSeparator$$module$tolatex("\\sqrt{@content}");
      break;
    case "mtable":
      a = renderTable$$module$tolatex;
      break;
    case "mtr":
      a = getRender_joinSeparator$$module$tolatex("@content \\\\ ", " & ");
      break;
    case "mtd":
      a = getRender_joinSeparator$$module$tolatex("@content");
      break;
    case "mfrac":
      a = renderMfrac$$module$tolatex;
      break;
    case "mfenced":
      a = renderMfenced$$module$tolatex;
      break;
    case "mi":
    case "mn":
    case "mo":
    case "ms":
    case "mtext":
      a = getRender_joinSeparator$$module$tolatex("@content");
      break;
    case "mphantom":
      a = renderMphantom$$module$tolatex;
      break;
    default:
      a = getRender_joinSeparator$$module$tolatex("@content");
  }
  return a;
}
function renderTable$$module$tolatex(a, c) {
  let b = NodeTool$$module$tolatex.getAttr(a, "columnalign", "");
  return getRender_joinSeparator$$module$tolatex(
    "\\begin{array}" +
      ("" == b ? "{cc}" : "{" + b + "}") +
      " @content \\end{array}"
  )(a, c);
}
function renderMfrac$$module$tolatex(a, c) {
  var [b] = [
    NodeTool$$module$tolatex.getAttr(a, "linethickness", "medium"),
    NodeTool$$module$tolatex.getAttr(a, "bevelled", "false"),
  ];
  -1 < ["0", "0px"].indexOf(b)
    ? ((b = NodeTool$$module$tolatex.getPrntBrackets(a)),
      (b =
        "(" === b.lb && ")" === b.rb
          ? getRender_default$$module$tolatex(
              "\\DELETE_BRACKET_L\\binom{@1}{@2}\\DELETE_BRACKET_R"
            )
          : getRender_default$$module$tolatex("{}_{@2}^{@1}")))
    : (b = getRender_default$$module$tolatex("\\frac{@1}{@2}"));
  return b(a, c);
}
function renderMfenced$$module$tolatex(a, c) {
  const [b, d, e] = [
      NodeTool$$module$tolatex.getAttr(a, "open", "("),
      NodeTool$$module$tolatex.getAttr(a, "close", ")"),
      NodeTool$$module$tolatex.getAttr(a, "separators", ","),
    ],
    [f, g] = [
      Brackets$$module$tolatex.parseLeft(b),
      Brackets$$module$tolatex.parseRight(d),
    ],
    k = e.split("").filter((h) => 1 === h.trim().length);
  return getRender_joinSeparators$$module$tolatex(`${f}@content${g}`, k)(a, c);
}
function renderMmultiscripts$$module$tolatex(a, c) {
  if (0 === c.length) return "";
  a = -1;
  let b = null;
  Array.prototype.forEach.call(c, (h) => {
    "mprescripts" === NodeTool$$module$tolatex.getNodeName(h) && (b = h);
  });
  b && (a = Array.prototype.indexOf.call(c, b));
  c = renderChildren$$module$tolatex(c);
  const d = (h, m) => [h.slice(0, m), h.slice(m + 1, h.length)],
    e = (h) => {
      if (0 < h.length) {
        const m = [],
          n = [];
        h.forEach((l, p) => {
          0 === (p + 1) % 2 ? n.push(l) : m.push(l);
        });
        return [
          0 < m.length ? `_{${m.join(" ")}}` : "",
          0 < n.length ? `^{${n.join(" ")}}` : "",
        ].join("");
      }
      return "";
    },
    f = c.shift();
  let g = [],
    k = [];
  -1 === a ? (k = c) : ([k, g] = d(c, a - 1));
  return [e(g), f, e(k)].join("");
}
function renderMsubsup$$module$tolatex(a, c) {
  var b = NodeTool$$module$tolatex.getNodeName(a),
    d = flattenNodeTreeByNodeName$$module$tolatex(a, b);
  a = void 0;
  for (let e = 0; e < d.length - 1; ) {
    c = parse$$module$tolatex(d[e + 1]).trim();
    const f = "msubsup" == b ? parse$$module$tolatex(d[e + 2]).trim() : void 0;
    b = ("msup" == b ? "^" : "_") + (1 == c.length ? "@2" : "{@2}");
    const g = f && 1 == f.length ? "^@3" : f ? "^{@3}" : "";
    a ||= parse$$module$tolatex(d[e]).trim();
    0 == a.indexOf("\\mathrm{") && (a = a.substring(8).slice(0, -1).trim());
    d = MathSymbol$$module$tolatex.getFuncSymbol(a);
    d = getMatchValueByChar$$module$tolatex({
      decimals: MathSymbol$$module$tolatex.overScript.decimals,
      values: MathSymbol$$module$tolatex.overScript.templates,
      judgeChar: null,
      defaultValue: (d && d.limits ? "{@1}" : "@1") + b + g,
    });
    a = renderTemplate$$module$tolatex(d.replace("@v", "@1"), [a, c, f]);
    break;
  }
  return a;
}
function renderMunderover$$module$tolatex(a, c) {
  c = NodeTool$$module$tolatex.getNodeName(a);
  a = flattenNodeTreeByNodeName$$module$tolatex(a, c);
  let b = void 0;
  const d = "munderover" == c ? a.length - 2 : a.length - 1;
  for (let f = 0; f < d; f++) {
    const g = parse$$module$tolatex(a[f + 1]).trim(),
      k = "munderover" == c ? parse$$module$tolatex(a[f + 2]).trim() : void 0;
    var e = ("mover" == c ? "^" : "_") + (1 == g.length ? "@2" : "{@2}");
    let h = k && 1 == k.length ? "^@3" : k ? "^{@3}" : "";
    const m =
      "munderover" == c
        ? {}
        : "mover" == c
        ? {
            "\u00af": "\\overline{@1}",
            "\u02d8": "\\breve{@1}",
            "\u23de": "\\overbrace{@1}",
            "^": "\\hat{@1}",
            "\u0302": "\\hat{@1}",
            "\u02c7": "\\check{@1}",
            "\u2026": "\\dddot{@1}",
            "\u20db": "\\dddot{@1}",
            "`": "\\grave{@1}",
            "\u00b4": "\\acute{@1}",
            "\\leftarrow": "\\overleftarrow{@1}",
            "\\rightarrow": "\\overrightarrow{@1}",
            "\\leftrightarrow": "\\overleftrightarrow{@1}",
            "\\leftharpoonup": "\\overleftharpoon{@1}",
            "\\rightharpoonup": "\\overrightharpoon{@1}",
            "\\sim": "\\widetilde{@1}",
            "\\~": "\\widetilde{@1}",
            "\\.": "\\dot{@1}",
            '\\"': "\\ddot{@1}",
            "-": "\\bar{@1}",
            "\\bar": "\\bar{@1}",
            "\u033f": "\\bar{\\bar{@1}}",
            "\\overline": "\\overline{@1}",
            "\\u": "\\breve{@1}",
            "\\hat": "\\widehat{@1}",
            "\\v": "\\widecheck{@1}",
            "\\dddot": "\\dddot{@1}",
            "\\grave": "\\grave{@1}",
            "\\'": "\\acute{@1}",
            "\\frown": "\\wideparen{@1}",
            "\u23dc": "\\wideparen{@1}",
          }
        : {
            "\\_": "\\underline{@1}",
            "\u23df": "\\underbrace{@1}",
            "\\smile": "\\underparen{@1}",
            "\u23dd": "\\underparen{@1}",
            "\\underline": "\\underline{@1}",
          };
    b ||= parse$$module$tolatex(a[f]).trim();
    0 == b.indexOf("\\mathrm{") && (b = b.substring(8).slice(0, -1).trim());
    const n = MathSymbol$$module$tolatex.getFuncSymbol(b);
    let l = "\\mathop{@1}\\limits";
    void 0 != m[g.trim()]
      ? (l = m[g.trim()])
      : (n && n.limits
          ? (l = "@1")
          : n
          ? (l = "@1\\limits")
          : "mover" == c && 0 == b.indexOf("\\overbrace")
          ? (l = "@1")
          : "munder" == c && 0 == b.indexOf("\\underbrace")
          ? (l = "@1")
          : MathSymbol$$module$tolatex.getFuncSymbol("\\mathop").limits &&
            (l = "\\mathop{@1}"),
        (l += e + h));
    e = getMatchValueByChar$$module$tolatex({
      decimals: MathSymbol$$module$tolatex.overScript.decimals,
      values: MathSymbol$$module$tolatex.overScript.templates,
      judgeChar: null,
      defaultValue: l,
    });
    b = renderTemplate$$module$tolatex(e.replace("@v", "@1"), [b, g, k]);
  }
  return b;
}
function flattenNodeTreeByNodeName$$module$tolatex(a, c) {
  let b = [];
  a = NodeTool$$module$tolatex.getChildren(a);
  Array.prototype.forEach.call(a, (d) => {
    NodeTool$$module$tolatex.getNodeName(d) === c
      ? (b = b.concat(flattenNodeTreeByNodeName$$module$tolatex(d, c, b)))
      : b.push(d);
  });
  return b;
}
function getMatchValueByChar$$module$tolatex(a) {
  const { decimals: c, values: b, judgeChar: d, defaultValue: e = null } = a;
  return d && 1 === d.length && ((a = c.indexOf(d.charCodeAt(0))), -1 < a)
    ? b[a]
    : e;
}
function renderMphantom$$module$tolatex(a, c) {
  return "";
}
function getRender_default$$module$tolatex(a) {
  return function (c, b) {
    c = renderChildren$$module$tolatex(b);
    if ("{@1}^{@2}" == a && 2 == b.length) {
      var d = b[0].localName.toLowerCase();
      const e = b[0].textContent.length,
        f = b[1].localName.toLowerCase();
      b = b[1].textContent.length;
      d = -1 != ["mo", "mn", "mi"].indexOf(d) && 1 == e ? "@1^" : "{@1}^";
      d += -1 != ["mo", "mn", "mi"].indexOf(f) && 1 == b ? "@2" : "{@2}";
      return renderTemplate$$module$tolatex(d, c);
    }
    return renderTemplate$$module$tolatex(a, c);
  };
}
function renderTemplate$$module$tolatex(a, c) {
  return a.replace(/@\d+/g, (b) => {
    b = parseInt(b.substring(1, b.length)) - 1;
    return c[b];
  });
}
function getRender_joinSeparator$$module$tolatex(a, c = "") {
  return function (b, d) {
    b = renderChildren$$module$tolatex(d);
    return a.replace("@content", b.join(c));
  };
}
function getRender_joinSeparators$$module$tolatex(a, c) {
  return function (b, d) {
    const e = renderChildren$$module$tolatex(d);
    b = "";
    b =
      0 === c.length
        ? e.join("")
        : e.reduce((f, g, k) => {
            f += g;
            k < e.length - 1 && (f += c[k] || c[c.length - 1]);
            return f;
          }, "");
    return a.replace("@content", b);
  };
}
var $jscompDefaultExport$$module$tolatex = { convert },
  module$tolatex = {};
module$tolatex.default = $jscompDefaultExport$$module$tolatex;
